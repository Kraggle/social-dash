import t from"./core.element.js";import{_alignPixel as e,_measureText as i,renderText as s,clipArea as o,unclipArea as r}from"../helpers/helpers.canvas.js";import{callback as a,each as n,finiteOrDefault as l,isArray as h,isFinite as c,isNullOrUndef as g,isObject as d,valueOrDefault as f}from"../helpers/helpers.core.js";import{toDegrees as p,toRadians as m,_int16Range as b,_limitValue as x,HALF_PI as u}from"../helpers/helpers.math.js";import{_alignStartEnd as k,_toLeftRightCenter as _}from"../helpers/helpers.extras.js";import{toFont as L,toPadding as w,_addGrace as T}from"../helpers/helpers.options.js";import"./core.scale.defaults.js";import{autoSkip as v}from"./core.scale.autoskip.js";const M=(t,e,i)=>"top"===e||"left"===e?t[e]+i:t[e]-i;function C(t,e){const i=[],s=t.length/e,o=t.length;let r=0;for(;r<o;r+=s)i.push(t[Math.floor(r)]);return i}function y(t,e,i){const s=t.ticks.length,o=Math.min(e,s-1),r=t._startPixel,a=t._endPixel,n=1e-6;let l,h=t.getPixelForTick(o);if(!(i&&(l=1===s?Math.max(h-r,a-h):0===e?(t.getPixelForTick(1)-h)/2:(h-t.getPixelForTick(o-1))/2,h+=o<e?l:-l,h<r-n||h>a+n)))return h}function P(t){return t.drawTicks?t.tickLength:0}function D(t,e){if(!t.display)return 0;const i=L(t.font,e),s=w(t.padding);return(h(t.text)?t.text.length:1)*i.lineHeight+s.height}function z(t,e,i){let s=_(t);return(i&&"right"!==e||!i&&"right"===e)&&(s=(t=>"left"===t?"right":"right"===t?"left":t)(s)),s}export default class F extends t{constructor(t){super(),this.id=t.id,this.type=t.type,this.options=void 0,this.ctx=t.ctx,this.chart=t.chart,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this._margins={left:0,right:0,top:0,bottom:0},this.maxWidth=void 0,this.maxHeight=void 0,this.paddingTop=void 0,this.paddingBottom=void 0,this.paddingLeft=void 0,this.paddingRight=void 0,this.axis=void 0,this.labelRotation=void 0,this.min=void 0,this.max=void 0,this._range=void 0,this.ticks=[],this._gridLineItems=null,this._labelItems=null,this._labelSizes=null,this._length=0,this._maxLength=0,this._longestTextCache={},this._startPixel=void 0,this._endPixel=void 0,this._reversePixels=!1,this._userMax=void 0,this._userMin=void 0,this._suggestedMax=void 0,this._suggestedMin=void 0,this._ticksLength=0,this._borderValue=0,this._cache={},this._dataLimitsCached=!1,this.$context=void 0}init(t){const e=this;e.options=t.setContext(e.getContext()),e.axis=t.axis,e._userMin=e.parse(t.min),e._userMax=e.parse(t.max),e._suggestedMin=e.parse(t.suggestedMin),e._suggestedMax=e.parse(t.suggestedMax)}parse(t,e){return t}getUserBounds(){let{_userMin:t,_userMax:e,_suggestedMin:i,_suggestedMax:s}=this;return t=l(t,Number.POSITIVE_INFINITY),e=l(e,Number.NEGATIVE_INFINITY),i=l(i,Number.POSITIVE_INFINITY),s=l(s,Number.NEGATIVE_INFINITY),{min:l(t,i),max:l(e,s),minDefined:c(t),maxDefined:c(e)}}getMinMax(t){const e=this;let i,{min:s,max:o,minDefined:r,maxDefined:a}=e.getUserBounds();if(r&&a)return{min:s,max:o};const n=e.getMatchingVisibleMetas();for(let l=0,h=n.length;l<h;++l)i=n[l].controller.getMinMax(e,t),r||(s=Math.min(s,i.min)),a||(o=Math.max(o,i.max));return{min:l(s,l(o,s)),max:l(o,l(s,o))}}getPadding(){const t=this;return{left:t.paddingLeft||0,top:t.paddingTop||0,right:t.paddingRight||0,bottom:t.paddingBottom||0}}getTicks(){return this.ticks}getLabels(){const t=this.chart.data;return this.options.labels||(this.isHorizontal()?t.xLabels:t.yLabels)||t.labels||[]}beforeLayout(){this._cache={},this._dataLimitsCached=!1}beforeUpdate(){a(this.options.beforeUpdate,[this])}update(t,e,i){const s=this,o=s.options.ticks,r=o.sampleSize;s.beforeUpdate(),s.maxWidth=t,s.maxHeight=e,s._margins=i=Object.assign({left:0,right:0,top:0,bottom:0},i),s.ticks=null,s._labelSizes=null,s._gridLineItems=null,s._labelItems=null,s.beforeSetDimensions(),s.setDimensions(),s.afterSetDimensions(),s._maxLength=s.isHorizontal()?s.width+i.left+i.right:s.height+i.top+i.bottom,s._dataLimitsCached||(s.beforeDataLimits(),s.determineDataLimits(),s.afterDataLimits(),s._range=T(s,s.options.grace),s._dataLimitsCached=!0),s.beforeBuildTicks(),s.ticks=s.buildTicks()||[],s.afterBuildTicks();const a=r<s.ticks.length;s._convertTicksToLabels(a?C(s.ticks,r):s.ticks),s.configure(),s.beforeCalculateLabelRotation(),s.calculateLabelRotation(),s.afterCalculateLabelRotation(),o.display&&(o.autoSkip||"auto"===o.source)&&(s.ticks=v(s,s.ticks),s._labelSizes=null),a&&s._convertTicksToLabels(s.ticks),s.beforeFit(),s.fit(),s.afterFit(),s.afterUpdate()}configure(){const t=this;let e,i,s=t.options.reverse;t.isHorizontal()?(e=t.left,i=t.right):(e=t.top,i=t.bottom,s=!s),t._startPixel=e,t._endPixel=i,t._reversePixels=s,t._length=i-e,t._alignToPixels=t.options.alignToPixels}afterUpdate(){a(this.options.afterUpdate,[this])}beforeSetDimensions(){a(this.options.beforeSetDimensions,[this])}setDimensions(){const t=this;t.isHorizontal()?(t.width=t.maxWidth,t.left=0,t.right=t.width):(t.height=t.maxHeight,t.top=0,t.bottom=t.height),t.paddingLeft=0,t.paddingTop=0,t.paddingRight=0,t.paddingBottom=0}afterSetDimensions(){a(this.options.afterSetDimensions,[this])}_callHooks(t){const e=this;e.chart.notifyPlugins(t,e.getContext()),a(e.options[t],[e])}beforeDataLimits(){this._callHooks("beforeDataLimits")}determineDataLimits(){}afterDataLimits(){this._callHooks("afterDataLimits")}beforeBuildTicks(){this._callHooks("beforeBuildTicks")}buildTicks(){return[]}afterBuildTicks(){this._callHooks("afterBuildTicks")}beforeTickToLabelConversion(){a(this.options.beforeTickToLabelConversion,[this])}generateTickLabels(t){const e=this,i=e.options.ticks;let s,o,r;for(s=0,o=t.length;s<o;s++)r=t[s],r.label=a(i.callback,[r.value,s,t],e)}afterTickToLabelConversion(){a(this.options.afterTickToLabelConversion,[this])}beforeCalculateLabelRotation(){a(this.options.beforeCalculateLabelRotation,[this])}calculateLabelRotation(){const t=this,e=t.options,i=e.ticks,s=t.ticks.length,o=i.minRotation||0,r=i.maxRotation;let a,n,l,h=o;if(!t._isVisible()||!i.display||o>=r||s<=1||!t.isHorizontal())return void(t.labelRotation=o);const c=t._getLabelSizes(),g=c.widest.width,d=c.highest.height,f=x(t.chart.width-g,0,t.maxWidth);a=e.offset?t.maxWidth/s:f/(s-1),g+6>a&&(a=f/(s-(e.offset?.5:1)),n=t.maxHeight-P(e.grid)-i.padding-D(e.title,t.chart.options.font),l=Math.sqrt(g*g+d*d),h=p(Math.min(Math.asin(x((c.highest.height+6)/a,-1,1)),Math.asin(x(n/l,-1,1))-Math.asin(x(d/l,-1,1)))),h=Math.max(o,Math.min(r,h))),t.labelRotation=h}afterCalculateLabelRotation(){a(this.options.afterCalculateLabelRotation,[this])}beforeFit(){a(this.options.beforeFit,[this])}fit(){const t=this,e={width:0,height:0},{chart:i,options:{ticks:s,title:o,grid:r}}=t,a=t._isVisible(),n=t.isHorizontal();if(a){const a=D(o,i.options.font);if(n?(e.width=t.maxWidth,e.height=P(r)+a):(e.height=t.maxHeight,e.width=P(r)+a),s.display&&t.ticks.length){const{first:i,last:o,widest:r,highest:a}=t._getLabelSizes(),l=2*s.padding,h=m(t.labelRotation),c=Math.cos(h),g=Math.sin(h);if(n){const i=s.mirror?0:g*r.width+c*a.height;e.height=Math.min(t.maxHeight,e.height+i+l)}else{const i=s.mirror?0:c*r.width+g*a.height;e.width=Math.min(t.maxWidth,e.width+i+l)}t._calculatePadding(i,o,g,c)}}t._handleMargins(),n?(t.width=t._length=i.width-t._margins.left-t._margins.right,t.height=e.height):(t.width=e.width,t.height=t._length=i.height-t._margins.top-t._margins.bottom)}_calculatePadding(t,e,i,s){const o=this,{ticks:{align:r,padding:a},position:n}=o.options,l=0!==o.labelRotation,h="top"!==n&&"x"===o.axis;if(o.isHorizontal()){const n=o.getPixelForTick(0)-o.left,c=o.right-o.getPixelForTick(o.ticks.length-1);let g=0,d=0;l?h?(g=s*t.width,d=i*e.height):(g=i*t.height,d=s*e.width):"start"===r?d=e.width:"end"===r?g=t.width:(g=t.width/2,d=e.width/2),o.paddingLeft=Math.max((g-n+a)*o.width/(o.width-n),0),o.paddingRight=Math.max((d-c+a)*o.width/(o.width-c),0)}else{let i=e.height/2,s=t.height/2;"start"===r?(i=0,s=t.height):"end"===r&&(i=e.height,s=0),o.paddingTop=i+a,o.paddingBottom=s+a}}_handleMargins(){const t=this;t._margins&&(t._margins.left=Math.max(t.paddingLeft,t._margins.left),t._margins.top=Math.max(t.paddingTop,t._margins.top),t._margins.right=Math.max(t.paddingRight,t._margins.right),t._margins.bottom=Math.max(t.paddingBottom,t._margins.bottom))}afterFit(){a(this.options.afterFit,[this])}isHorizontal(){const{axis:t,position:e}=this.options;return"top"===e||"bottom"===e||"x"===t}isFullSize(){return this.options.fullSize}_convertTicksToLabels(t){const e=this;let i,s;for(e.beforeTickToLabelConversion(),e.generateTickLabels(t),i=0,s=t.length;i<s;i++)g(t[i].label)&&(t.splice(i,1),s--,i--);e.afterTickToLabelConversion()}_getLabelSizes(){const t=this;let e=t._labelSizes;if(!e){const i=t.options.ticks.sampleSize;let s=t.ticks;i<s.length&&(s=C(s,i)),t._labelSizes=e=t._computeLabelSizes(s,s.length)}return e}_computeLabelSizes(t,e){const{ctx:s,_longestTextCache:o}=this,r=[],a=[];let l,c,d,f,p,m,b,x,u,k,_,L=0,w=0;for(l=0;l<e;++l){if(f=t[l].label,p=this._resolveTickFontOptions(l),s.font=m=p.string,b=o[m]=o[m]||{data:{},gc:[]},x=p.lineHeight,u=k=0,g(f)||h(f)){if(h(f))for(c=0,d=f.length;c<d;++c)_=f[c],g(_)||h(_)||(u=i(s,b.data,b.gc,u,_),k+=x)}else u=i(s,b.data,b.gc,u,f),k=x;r.push(u),a.push(k),L=Math.max(u,L),w=Math.max(k,w)}!function(t,e){n(t,(t=>{const i=t.gc,s=i.length/2;let o;if(s>e){for(o=0;o<s;++o)delete t.data[i[o]];i.splice(0,s)}}))}(o,e);const T=r.indexOf(L),v=a.indexOf(w),M=t=>({width:r[t]||0,height:a[t]||0});return{first:M(0),last:M(e-1),widest:M(T),highest:M(v),widths:r,heights:a}}getLabelForValue(t){return t}getPixelForValue(t,e){return NaN}getValueForPixel(t){}getPixelForTick(t){const e=this.ticks;return t<0||t>e.length-1?null:this.getPixelForValue(e[t].value)}getPixelForDecimal(t){const i=this;i._reversePixels&&(t=1-t);const s=i._startPixel+t*i._length;return b(i._alignToPixels?e(i.chart,s,0):s)}getDecimalForPixel(t){const e=(t-this._startPixel)/this._length;return this._reversePixels?1-e:e}getBasePixel(){return this.getPixelForValue(this.getBaseValue())}getBaseValue(){const{min:t,max:e}=this;return t<0&&e<0?e:t>0&&e>0?t:0}getContext(t){const e=this,i=e.ticks||[];if(t>=0&&t<i.length){const s=i[t];return s.$context||(s.$context=function(t,e,i){return Object.assign(Object.create(t),{tick:i,index:e,type:"tick"})}(e.getContext(),t,s))}return e.$context||(e.$context=(s=e.chart.getContext(),o=e,Object.assign(Object.create(s),{scale:o,type:"scale"})));var s,o}_tickSize(){const t=this,e=t.options.ticks,i=m(t.labelRotation),s=Math.abs(Math.cos(i)),o=Math.abs(Math.sin(i)),r=t._getLabelSizes(),a=e.autoSkipPadding||0,n=r?r.widest.width+a:0,l=r?r.highest.height+a:0;return t.isHorizontal()?l*s>n*o?n/s:l/o:l*o<n*s?l/s:n/o}_isVisible(){const t=this.options.display;return"auto"!==t?!!t:this.getMatchingVisibleMetas().length>0}_computeGridLineItems(t){const i=this,s=i.axis,o=i.chart,r=i.options,{grid:a,position:n}=r,l=a.offset,h=i.isHorizontal(),c=i.ticks.length+(l?1:0),g=P(a),p=[],m=a.setContext(i.getContext()),b=m.drawBorder?m.borderWidth:0,x=b/2,u=function(t){return e(o,t,b)};let k,_,L,w,T,v,M,C,D,z,F,S;if("top"===n)k=u(i.bottom),v=i.bottom-g,C=k-x,z=u(t.top)+x,S=t.bottom;else if("bottom"===n)k=u(i.top),z=t.top,S=u(t.bottom)-x,v=k+x,C=i.top+g;else if("left"===n)k=u(i.right),T=i.right-g,M=k-x,D=u(t.left)+x,F=t.right;else if("right"===n)k=u(i.left),D=t.left,F=u(t.right)-x,T=k+x,M=i.left+g;else if("x"===s){if("center"===n)k=u((t.top+t.bottom)/2+.5);else if(d(n)){const t=Object.keys(n)[0],e=n[t];k=u(i.chart.scales[t].getPixelForValue(e))}z=t.top,S=t.bottom,v=k+x,C=v+g}else if("y"===s){if("center"===n)k=u((t.left+t.right)/2);else if(d(n)){const t=Object.keys(n)[0],e=n[t];k=u(i.chart.scales[t].getPixelForValue(e))}T=k-x,M=T-g,D=t.left,F=t.right}const B=f(r.ticks.maxTicksLimit,c),I=Math.max(1,Math.ceil(c/B));for(_=0;_<c;_+=I){const t=a.setContext(i.getContext(_)),s=t.lineWidth,r=t.color,n=a.borderDash||[],c=t.borderDashOffset,g=t.tickWidth,d=t.tickColor,f=t.tickBorderDash||[],m=t.tickBorderDashOffset;L=y(i,_,l),void 0!==L&&(w=e(o,L,s),h?T=M=D=F=w:v=C=z=S=w,p.push({tx1:T,ty1:v,tx2:M,ty2:C,x1:D,y1:z,x2:F,y2:S,width:s,color:r,borderDash:n,borderDashOffset:c,tickWidth:g,tickColor:d,tickBorderDash:f,tickBorderDashOffset:m}))}return i._ticksLength=c,i._borderValue=k,p}_computeLabelItems(t){const e=this,i=e.axis,s=e.options,{position:o,ticks:r}=s,a=e.isHorizontal(),n=e.ticks,{align:l,crossAlign:c,padding:g,mirror:f}=r,p=P(s.grid),b=p+g,x=f?-g:b,u=-m(e.labelRotation),k=[];let _,L,T,v,M,C,y,D,z,F,S,B,I="middle";if("top"===o)C=e.bottom-x,y=e._getXAxisLabelAlignment();else if("bottom"===o)C=e.top+x,y=e._getXAxisLabelAlignment();else if("left"===o){const t=e._getYAxisLabelAlignment(p);y=t.textAlign,M=t.x}else if("right"===o){const t=e._getYAxisLabelAlignment(p);y=t.textAlign,M=t.x}else if("x"===i){if("center"===o)C=(t.top+t.bottom)/2+b;else if(d(o)){const t=Object.keys(o)[0],i=o[t];C=e.chart.scales[t].getPixelForValue(i)+b}y=e._getXAxisLabelAlignment()}else if("y"===i){if("center"===o)M=(t.left+t.right)/2-b;else if(d(o)){const t=Object.keys(o)[0],i=o[t];M=e.chart.scales[t].getPixelForValue(i)}y=e._getYAxisLabelAlignment(p).textAlign}"y"===i&&("start"===l?I="top":"end"===l&&(I="bottom"));const A=e._getLabelSizes();for(_=0,L=n.length;_<L;++_){T=n[_],v=T.label;const t=r.setContext(e.getContext(_));D=e.getPixelForTick(_)+r.labelOffset,z=e._resolveTickFontOptions(_),F=z.lineHeight,S=h(v)?v.length:1;const i=S/2,s=t.color,l=t.textStrokeColor,g=t.textStrokeWidth;let d;if(a?(M=D,B="top"===o?"near"===c||0!==u?-S*F+F/2:"center"===c?-A.highest.height/2-i*F+F:-A.highest.height+F/2:"near"===c||0!==u?F/2:"center"===c?A.highest.height/2-i*F:A.highest.height-S*F,f&&(B*=-1)):(C=D,B=(1-S)*F/2),t.showLabelBackdrop){const e=w(t.backdropPadding),i=A.heights[_],s=A.widths[_];let o=C+B-e.top,r=M-e.left;switch(I){case"middle":o-=i/2;break;case"bottom":o-=i;break;default:break}switch(y){case"center":r-=s/2;break;case"right":r-=s;break;default:break}d={left:r,top:o,width:s+e.width,height:i+e.height,color:t.backdropColor}}k.push({rotation:u,label:v,font:z,color:s,strokeColor:l,strokeWidth:g,textOffset:B,textAlign:y,textBaseline:I,translation:[M,C],backdrop:d})}return k}_getXAxisLabelAlignment(){const{position:t,ticks:e}=this.options;if(-m(this.labelRotation))return"top"===t?"left":"right";let i="center";return"start"===e.align?i="left":"end"===e.align&&(i="right"),i}_getYAxisLabelAlignment(t){const e=this,{position:i,ticks:{crossAlign:s,mirror:o,padding:r}}=e.options,a=t+r,n=e._getLabelSizes().widest.width;let l,h;return"left"===i?o?(l="left",h=e.right+r):(h=e.right-a,"near"===s?l="right":"center"===s?(l="center",h-=n/2):(l="left",h=e.left)):"right"===i?o?(l="right",h=e.left+r):(h=e.left+a,"near"===s?l="left":"center"===s?(l="center",h+=n/2):(l="right",h=e.right)):l="right",{textAlign:l,x:h}}_computeLabelArea(){const t=this;if(t.options.ticks.mirror)return;const e=t.chart,i=t.options.position;return"left"===i||"right"===i?{top:0,left:t.left,bottom:e.height,right:t.right}:"top"===i||"bottom"===i?{top:t.top,left:0,bottom:t.bottom,right:e.width}:void 0}drawBackground(){const{ctx:t,options:{backgroundColor:e},left:i,top:s,width:o,height:r}=this;e&&(t.save(),t.fillStyle=e,t.fillRect(i,s,o,r),t.restore())}getLineWidthForValue(t){const e=this,i=e.options.grid;if(!e._isVisible()||!i.display)return 0;const s=e.ticks.findIndex((e=>e.value===t));if(s>=0){return i.setContext(e.getContext(s)).lineWidth}return 0}drawGrid(t){const e=this,i=e.options.grid,s=e.ctx,o=e._gridLineItems||(e._gridLineItems=e._computeGridLineItems(t));let r,a;const n=(t,e,i)=>{i.width&&i.color&&(s.save(),s.lineWidth=i.width,s.strokeStyle=i.color,s.setLineDash(i.borderDash||[]),s.lineDashOffset=i.borderDashOffset,s.beginPath(),s.moveTo(t.x,t.y),s.lineTo(e.x,e.y),s.stroke(),s.restore())};if(i.display)for(r=0,a=o.length;r<a;++r){const t=o[r];i.drawOnChartArea&&n({x:t.x1,y:t.y1},{x:t.x2,y:t.y2},t),i.drawTicks&&n({x:t.tx1,y:t.ty1},{x:t.tx2,y:t.ty2},{color:t.tickColor,width:t.tickWidth,borderDash:t.tickBorderDash,borderDashOffset:t.tickBorderDashOffset})}}drawBorder(){const t=this,{chart:i,ctx:s,options:{grid:o}}=t,r=o.setContext(t.getContext()),a=o.drawBorder?r.borderWidth:0;if(!a)return;const n=o.setContext(t.getContext(0)).lineWidth,l=t._borderValue;let h,c,g,d;t.isHorizontal()?(h=e(i,t.left,a)-a/2,c=e(i,t.right,n)+n/2,g=d=l):(g=e(i,t.top,a)-a/2,d=e(i,t.bottom,n)+n/2,h=c=l),s.save(),s.lineWidth=r.borderWidth,s.strokeStyle=r.borderColor,s.beginPath(),s.moveTo(h,g),s.lineTo(c,d),s.stroke(),s.restore()}drawLabels(t){const e=this;if(!e.options.ticks.display)return;const i=e.ctx,a=e._computeLabelArea();a&&o(i,a);const n=e._labelItems||(e._labelItems=e._computeLabelItems(t));let l,h;for(l=0,h=n.length;l<h;++l){const t=n[l],e=t.font,o=t.label;t.backdrop&&(i.fillStyle=t.backdrop.color,i.fillRect(t.backdrop.left,t.backdrop.top,t.backdrop.width,t.backdrop.height));let r=t.textOffset;s(i,o,0,r,e,t)}a&&r(i)}drawTitle(){const{ctx:t,options:{position:e,title:i,reverse:o}}=this;if(!i.display)return;const r=L(i.font),a=w(i.padding),n=i.align;let l=r.lineHeight/2;"bottom"===e||"center"===e||d(e)?(l+=a.bottom,h(i.text)&&(l+=r.lineHeight*(i.text.length-1))):l+=a.top;const{titleX:c,titleY:g,maxWidth:f,rotation:p}=function(t,e,i,s){const{top:o,left:r,bottom:a,right:n,chart:l}=t,{chartArea:h,scales:c}=l;let g,f,p,m=0;const b=a-o,x=n-r;if(t.isHorizontal()){if(f=k(s,r,n),d(i)){const t=Object.keys(i)[0],s=i[t];p=c[t].getPixelForValue(s)+b-e}else p="center"===i?(h.bottom+h.top)/2+b-e:M(t,i,e);g=n-r}else{if(d(i)){const t=Object.keys(i)[0],s=i[t];f=c[t].getPixelForValue(s)-x+e}else f="center"===i?(h.left+h.right)/2-x+e:M(t,i,e);p=k(s,a,o),m="left"===i?-u:u}return{titleX:f,titleY:p,maxWidth:g,rotation:m}}(this,l,e,n);s(t,i.text,0,0,r,{color:i.color,maxWidth:f,rotation:p,textAlign:z(n,e,o),textBaseline:"middle",translation:[c,g]})}draw(t){const e=this;e._isVisible()&&(e.drawBackground(),e.drawGrid(t),e.drawBorder(),e.drawTitle(),e.drawLabels(t))}_layers(){const t=this,e=t.options,i=e.ticks&&e.ticks.z||0,s=f(e.grid&&e.grid.z,-1);return t._isVisible()&&t.draw===F.prototype.draw?[{z:s,draw(e){t.drawBackground(),t.drawGrid(e),t.drawTitle()}},{z:s+1,draw(){t.drawBorder()}},{z:i,draw(e){t.drawLabels(e)}}]:[{z:i,draw(e){t.draw(e)}}]}getMatchingVisibleMetas(t){const e=this,i=e.chart.getSortedVisibleDatasetMetas(),s=e.axis+"AxisID",o=[];let r,a;for(r=0,a=i.length;r<a;++r){const a=i[r];a[s]!==e.id||t&&a.type!==t||o.push(a)}return o}_resolveTickFontOptions(t){const e=this.options.ticks.setContext(this.getContext(t));return L(e.font)}_maxDigits(){const t=this,e=t._resolveTickFontOptions(0).lineHeight;return(t.isHorizontal()?t.width:t.height)/e}}